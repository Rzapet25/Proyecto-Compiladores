
//----------------------------------------------------
// The following code was generated by CUP v0.11b 20160615 (GIT 4ac7450)
//----------------------------------------------------

package org.example.parser;

import java_cup.runtime.Symbol;
import java_cup.runtime.SymbolFactory;
import java_cup.runtime.lr_parser;
import org.example.ast.*;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

/** CUP v0.11b 20160615 (GIT 4ac7450) generated parser.
  */
@SuppressWarnings({"rawtypes"})
public class Parser extends lr_parser {

 public final Class getSymbolContainer() {
    return Symbols.class;
}

  /** Default constructor. */
  @Deprecated
  public Parser() {super();}

  /** Constructor which sets the default scanner. */
  @Deprecated
  public Parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public Parser(java_cup.runtime.Scanner s, SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\104\000\002\002\004\000\002\002\003\000\002\003" +
    "\003\000\002\003\004\000\002\004\003\000\002\004\003" +
    "\000\002\004\003\000\002\004\003\000\002\004\004\000" +
    "\002\004\004\000\002\005\007\000\002\006\011\000\002" +
    "\012\002\000\002\012\003\000\002\013\003\000\002\013" +
    "\005\000\002\014\003\000\002\014\004\000\002\014\006" +
    "\000\002\014\005\000\002\007\005\000\002\015\003\000" +
    "\002\015\005\000\002\010\003\000\002\010\003\000\002" +
    "\010\003\000\002\016\007\000\002\016\011\000\002\016" +
    "\010\000\002\016\012\000\002\021\006\000\002\021\007" +
    "\000\002\017\007\000\002\020\014\000\002\011\006\000" +
    "\002\022\002\000\002\022\003\000\002\023\003\000\002" +
    "\023\005\000\002\024\003\000\002\025\005\000\002\025" +
    "\003\000\002\026\003\000\002\026\005\000\002\026\005" +
    "\000\002\026\004\000\002\027\003\000\002\027\005\000" +
    "\002\027\005\000\002\027\005\000\002\027\005\000\002" +
    "\027\005\000\002\027\005\000\002\030\005\000\002\030" +
    "\005\000\002\030\003\000\002\031\005\000\002\031\005" +
    "\000\002\031\003\000\002\032\005\000\002\032\003\000" +
    "\002\032\003\000\002\032\003\000\002\032\003\000\002" +
    "\032\003\000\002\032\003\000\002\032\003\000\002\032" +
    "\004" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\211\000\040\004\007\005\037\006\016\011\010\012" +
    "\011\013\014\022\012\024\035\036\017\042\020\043\006" +
    "\044\030\045\025\046\015\047\036\001\002\000\052\002" +
    "\ufffc\004\ufffc\005\ufffc\006\ufffc\007\ufffc\010\ufffc\011\ufffc" +
    "\012\ufffc\013\ufffc\014\ufffc\015\ufffc\022\ufffc\024\ufffc\036" +
    "\ufffc\042\ufffc\043\ufffc\044\ufffc\045\ufffc\046\ufffc\047\ufffc" +
    "\001\002\000\052\002\ufffa\004\ufffa\005\ufffa\006\ufffa\007" +
    "\ufffa\010\ufffa\011\ufffa\012\ufffa\013\ufffa\014\ufffa\015\ufffa" +
    "\022\ufffa\024\ufffa\036\ufffa\042\ufffa\043\ufffa\044\ufffa\045" +
    "\ufffa\046\ufffa\047\ufffa\001\002\000\044\016\uffc3\017\uffc3" +
    "\020\uffc3\021\uffc3\023\uffc3\024\uffc3\025\uffc3\026\uffc3\027" +
    "\uffc3\030\uffc3\031\uffc3\032\uffc3\033\uffc3\034\uffc3\037\uffc3" +
    "\040\uffc3\041\uffc3\001\002\000\004\042\210\001\002\000" +
    "\024\022\012\024\035\036\017\042\020\043\006\044\030" +
    "\045\025\046\015\047\036\001\002\000\004\036\173\001" +
    "\002\000\022\024\035\036\017\042\054\043\006\044\030" +
    "\045\025\046\015\047\036\001\002\000\052\002\ufffb\004" +
    "\ufffb\005\ufffb\006\ufffb\007\ufffb\010\ufffb\011\ufffb\012\ufffb" +
    "\013\ufffb\014\ufffb\015\ufffb\022\ufffb\024\ufffb\036\ufffb\042" +
    "\ufffb\043\ufffb\044\ufffb\045\ufffb\046\ufffb\047\ufffb\001\002" +
    "\000\004\042\150\001\002\000\044\016\uffc0\017\uffc0\020" +
    "\uffc0\021\uffc0\023\uffc0\024\uffc0\025\uffc0\026\uffc0\027\uffc0" +
    "\030\uffc0\031\uffc0\032\uffc0\033\uffc0\034\uffc0\037\uffc0\040" +
    "\uffc0\041\uffc0\001\002\000\024\022\012\024\035\036\017" +
    "\042\020\043\006\044\030\045\025\046\015\047\036\001" +
    "\002\000\024\022\012\024\035\036\017\042\020\043\006" +
    "\044\030\045\025\046\015\047\036\001\002\000\050\016" +
    "\uffc4\017\uffc4\020\uffc4\021\uffc4\023\uffc4\024\uffc4\025\uffc4" +
    "\026\uffc4\027\uffc4\030\uffc4\031\uffc4\032\uffc4\033\uffc4\034" +
    "\uffc4\035\120\036\056\037\uffc4\040\uffc4\041\uffc4\001\002" +
    "\000\004\002\117\001\002\000\052\002\uffea\004\uffea\005" +
    "\uffea\006\uffea\007\uffea\010\uffea\011\uffea\012\uffea\013\uffea" +
    "\014\uffea\015\uffea\022\uffea\024\uffea\036\uffea\042\uffea\043" +
    "\uffea\044\uffea\045\uffea\046\uffea\047\uffea\001\002\000\050" +
    "\002\uffff\004\uffff\005\uffff\006\uffff\007\uffff\010\uffff\011" +
    "\uffff\012\uffff\013\uffff\015\uffff\022\uffff\024\uffff\036\uffff" +
    "\042\uffff\043\uffff\044\uffff\045\uffff\046\uffff\047\uffff\001" +
    "\002\000\044\016\uffca\017\uffca\020\uffca\021\uffca\023\uffca" +
    "\024\uffca\025\101\026\100\027\uffca\030\uffca\031\uffca\032" +
    "\uffca\033\uffca\034\uffca\037\uffca\040\uffca\041\uffca\001\002" +
    "\000\044\016\uffc1\017\uffc1\020\uffc1\021\uffc1\023\uffc1\024" +
    "\uffc1\025\uffc1\026\uffc1\027\uffc1\030\uffc1\031\uffc1\032\uffc1" +
    "\033\uffc1\034\uffc1\037\uffc1\040\uffc1\041\uffc1\001\002\000" +
    "\020\016\uffd7\017\uffd7\020\113\021\114\037\uffd7\040\uffd7" +
    "\041\uffd7\001\002\000\004\040\112\001\002\000\044\016" +
    "\uffc2\017\uffc2\020\uffc2\021\uffc2\023\uffc2\024\uffc2\025\uffc2" +
    "\026\uffc2\027\uffc2\030\uffc2\031\uffc2\032\uffc2\033\uffc2\034" +
    "\uffc2\037\uffc2\040\uffc2\041\uffc2\001\002\000\040\016\uffd3" +
    "\017\uffd3\020\uffd3\021\uffd3\023\071\024\074\027\066\030" +
    "\070\031\072\032\073\033\067\034\075\037\uffd3\040\uffd3" +
    "\041\uffd3\001\002\000\044\016\uffc7\017\uffc7\020\uffc7\021" +
    "\uffc7\023\uffc7\024\uffc7\025\uffc7\026\uffc7\027\uffc7\030\uffc7" +
    "\031\uffc7\032\uffc7\033\uffc7\034\uffc7\037\uffc7\040\uffc7\041" +
    "\uffc7\001\002\000\034\020\uffc5\021\uffc5\023\uffc5\024\uffc5" +
    "\025\uffc5\026\uffc5\027\uffc5\030\uffc5\031\uffc5\032\uffc5\033" +
    "\uffc5\034\uffc5\040\065\001\002\000\014\016\uffd8\017\uffd8" +
    "\037\uffd8\040\uffd8\041\uffd8\001\002\000\022\024\035\036" +
    "\017\042\054\043\006\044\030\045\025\046\015\047\036" +
    "\001\002\000\044\016\uffbf\017\uffbf\020\uffbf\021\uffbf\023" +
    "\uffbf\024\uffbf\025\uffbf\026\uffbf\027\uffbf\030\uffbf\031\uffbf" +
    "\032\uffbf\033\uffbf\034\uffbf\037\uffbf\040\uffbf\041\uffbf\001" +
    "\002\000\024\022\012\024\035\036\017\042\020\043\006" +
    "\044\030\045\025\046\015\047\036\001\002\000\052\002" +
    "\uffe9\004\uffe9\005\uffe9\006\uffe9\007\uffe9\010\uffe9\011\uffe9" +
    "\012\uffe9\013\uffe9\014\uffe9\015\uffe9\022\uffe9\024\uffe9\036" +
    "\uffe9\042\uffe9\043\uffe9\044\uffe9\045\uffe9\046\uffe9\047\uffe9" +
    "\001\002\000\052\002\ufffd\004\ufffd\005\ufffd\006\ufffd\007" +
    "\ufffd\010\ufffd\011\ufffd\012\ufffd\013\ufffd\014\ufffd\015\ufffd" +
    "\022\ufffd\024\ufffd\036\ufffd\042\ufffd\043\ufffd\044\ufffd\045" +
    "\ufffd\046\ufffd\047\ufffd\001\002\000\052\002\uffe8\004\uffe8" +
    "\005\uffe8\006\uffe8\007\uffe8\010\uffe8\011\uffe8\012\uffe8\013" +
    "\uffe8\014\uffe8\015\uffe8\022\uffe8\024\uffe8\036\uffe8\042\uffe8" +
    "\043\uffe8\044\uffe8\045\uffe8\046\uffe8\047\uffe8\001\002\000" +
    "\042\002\000\004\007\005\037\006\016\011\010\012\011" +
    "\013\014\022\012\024\035\036\017\042\020\043\006\044" +
    "\030\045\025\046\015\047\036\001\002\000\050\002\ufffe" +
    "\004\ufffe\005\ufffe\006\ufffe\007\ufffe\010\ufffe\011\ufffe\012" +
    "\ufffe\013\ufffe\015\ufffe\022\ufffe\024\ufffe\036\ufffe\042\ufffe" +
    "\043\ufffe\044\ufffe\045\ufffe\046\ufffe\047\ufffe\001\002\000" +
    "\006\040\052\041\051\001\002\000\006\040\uffec\041\uffec" +
    "\001\002\000\014\016\uffda\017\uffda\037\uffda\040\uffda\041" +
    "\uffda\001\002\000\044\016\uffc5\017\uffc5\020\uffc5\021\uffc5" +
    "\023\uffc5\024\uffc5\025\uffc5\026\uffc5\027\uffc5\030\uffc5\031" +
    "\uffc5\032\uffc5\033\uffc5\034\uffc5\037\uffc5\040\uffc5\041\uffc5" +
    "\001\002\000\024\022\012\024\035\036\017\042\020\043" +
    "\006\044\030\045\025\046\015\047\036\001\002\000\052" +
    "\002\uffed\004\uffed\005\uffed\006\uffed\007\uffed\010\uffed\011" +
    "\uffed\012\uffed\013\uffed\014\uffed\015\uffed\022\uffed\024\uffed" +
    "\036\uffed\042\uffed\043\uffed\044\uffed\045\uffed\046\uffed\047" +
    "\uffed\001\002\000\006\040\uffeb\041\uffeb\001\002\000\046" +
    "\016\uffc4\017\uffc4\020\uffc4\021\uffc4\023\uffc4\024\uffc4\025" +
    "\uffc4\026\uffc4\027\uffc4\030\uffc4\031\uffc4\032\uffc4\033\uffc4" +
    "\034\uffc4\036\056\037\uffc4\040\uffc4\041\uffc4\001\002\000" +
    "\044\016\uffbe\017\uffbe\020\uffbe\021\uffbe\023\uffbe\024\uffbe" +
    "\025\uffbe\026\uffbe\027\uffbe\030\uffbe\031\uffbe\032\uffbe\033" +
    "\uffbe\034\uffbe\037\uffbe\040\uffbe\041\uffbe\001\002\000\026" +
    "\022\012\024\035\036\017\037\uffde\042\020\043\006\044" +
    "\030\045\025\046\015\047\036\001\002\000\006\037\uffdc" +
    "\041\uffdc\001\002\000\006\037\uffdd\041\063\001\002\000" +
    "\004\037\062\001\002\000\044\016\uffdf\017\uffdf\020\uffdf" +
    "\021\uffdf\023\uffdf\024\uffdf\025\uffdf\026\uffdf\027\uffdf\030" +
    "\uffdf\031\uffdf\032\uffdf\033\uffdf\034\uffdf\037\uffdf\040\uffdf" +
    "\041\uffdf\001\002\000\024\022\012\024\035\036\017\042" +
    "\020\043\006\044\030\045\025\046\015\047\036\001\002" +
    "\000\006\037\uffdb\041\uffdb\001\002\000\052\002\ufff9\004" +
    "\ufff9\005\ufff9\006\ufff9\007\ufff9\010\ufff9\011\ufff9\012\ufff9" +
    "\013\ufff9\014\ufff9\015\ufff9\022\ufff9\024\ufff9\036\ufff9\042" +
    "\ufff9\043\ufff9\044\ufff9\045\ufff9\046\ufff9\047\ufff9\001\002" +
    "\000\022\024\035\036\017\042\054\043\006\044\030\045" +
    "\025\046\015\047\036\001\002\000\022\024\035\036\017" +
    "\042\054\043\006\044\030\045\025\046\015\047\036\001" +
    "\002\000\022\024\035\036\017\042\054\043\006\044\030" +
    "\045\025\046\015\047\036\001\002\000\022\024\035\036" +
    "\017\042\054\043\006\044\030\045\025\046\015\047\036" +
    "\001\002\000\022\024\035\036\017\042\054\043\006\044" +
    "\030\045\025\046\015\047\036\001\002\000\022\024\035" +
    "\036\017\042\054\043\006\044\030\045\025\046\015\047" +
    "\036\001\002\000\022\024\035\036\017\042\054\043\006" +
    "\044\030\045\025\046\015\047\036\001\002\000\022\024" +
    "\035\036\017\042\054\043\006\044\030\045\025\046\015" +
    "\047\036\001\002\000\024\016\uffcd\017\uffcd\020\uffcd\021" +
    "\uffcd\023\071\024\074\037\uffcd\040\uffcd\041\uffcd\001\002" +
    "\000\044\016\uffcb\017\uffcb\020\uffcb\021\uffcb\023\uffcb\024" +
    "\uffcb\025\101\026\100\027\uffcb\030\uffcb\031\uffcb\032\uffcb" +
    "\033\uffcb\034\uffcb\037\uffcb\040\uffcb\041\uffcb\001\002\000" +
    "\022\024\035\036\017\042\054\043\006\044\030\045\025" +
    "\046\015\047\036\001\002\000\022\024\035\036\017\042" +
    "\054\043\006\044\030\045\025\046\015\047\036\001\002" +
    "\000\044\016\uffc9\017\uffc9\020\uffc9\021\uffc9\023\uffc9\024" +
    "\uffc9\025\uffc9\026\uffc9\027\uffc9\030\uffc9\031\uffc9\032\uffc9" +
    "\033\uffc9\034\uffc9\037\uffc9\040\uffc9\041\uffc9\001\002\000" +
    "\044\016\uffc8\017\uffc8\020\uffc8\021\uffc8\023\uffc8\024\uffc8" +
    "\025\uffc8\026\uffc8\027\uffc8\030\uffc8\031\uffc8\032\uffc8\033" +
    "\uffc8\034\uffc8\037\uffc8\040\uffc8\041\uffc8\001\002\000\024" +
    "\016\uffcf\017\uffcf\020\uffcf\021\uffcf\023\071\024\074\037" +
    "\uffcf\040\uffcf\041\uffcf\001\002\000\024\016\uffd0\017\uffd0" +
    "\020\uffd0\021\uffd0\023\071\024\074\037\uffd0\040\uffd0\041" +
    "\uffd0\001\002\000\044\016\uffcc\017\uffcc\020\uffcc\021\uffcc" +
    "\023\uffcc\024\uffcc\025\101\026\100\027\uffcc\030\uffcc\031" +
    "\uffcc\032\uffcc\033\uffcc\034\uffcc\037\uffcc\040\uffcc\041\uffcc" +
    "\001\002\000\024\016\uffd1\017\uffd1\020\uffd1\021\uffd1\023" +
    "\071\024\074\037\uffd1\040\uffd1\041\uffd1\001\002\000\024" +
    "\016\uffce\017\uffce\020\uffce\021\uffce\023\071\024\074\037" +
    "\uffce\040\uffce\041\uffce\001\002\000\024\016\uffd2\017\uffd2" +
    "\020\uffd2\021\uffd2\023\071\024\074\037\uffd2\040\uffd2\041" +
    "\uffd2\001\002\000\052\002\ufff8\004\ufff8\005\ufff8\006\ufff8" +
    "\007\ufff8\010\ufff8\011\ufff8\012\ufff8\013\ufff8\014\ufff8\015" +
    "\ufff8\022\ufff8\024\ufff8\036\ufff8\042\ufff8\043\ufff8\044\ufff8" +
    "\045\ufff8\046\ufff8\047\ufff8\001\002\000\024\022\012\024" +
    "\035\036\017\042\054\043\006\044\030\045\025\046\015" +
    "\047\036\001\002\000\024\022\012\024\035\036\017\042" +
    "\054\043\006\044\030\045\025\046\015\047\036\001\002" +
    "\000\014\016\uffd5\017\uffd5\037\uffd5\040\uffd5\041\uffd5\001" +
    "\002\000\014\016\uffd6\017\uffd6\037\uffd6\040\uffd6\041\uffd6" +
    "\001\002\000\004\002\001\001\002\000\024\022\012\024" +
    "\035\036\017\042\020\043\006\044\030\045\025\046\015" +
    "\047\036\001\002\000\014\016\uffd9\017\uffd9\037\uffd9\040" +
    "\uffd9\041\uffd9\001\002\000\004\037\123\001\002\000\044" +
    "\016\uffc6\017\uffc6\020\uffc6\021\uffc6\023\uffc6\024\uffc6\025" +
    "\uffc6\026\uffc6\027\uffc6\030\uffc6\031\uffc6\032\uffc6\033\uffc6" +
    "\034\uffc6\037\uffc6\040\uffc6\041\uffc6\001\002\000\004\017" +
    "\125\001\002\000\040\004\007\005\037\006\016\011\010" +
    "\012\011\013\014\022\012\024\035\036\017\042\020\043" +
    "\006\044\030\045\025\046\015\047\036\001\002\000\046" +
    "\004\007\005\037\006\016\007\127\010\131\011\010\012" +
    "\011\013\014\015\130\022\012\024\035\036\017\042\020" +
    "\043\006\044\030\045\025\046\015\047\036\001\002\000" +
    "\040\004\007\005\037\006\016\011\010\012\011\013\014" +
    "\022\012\024\035\036\017\042\020\043\006\044\030\045" +
    "\025\046\015\047\036\001\002\000\052\002\uffe7\004\uffe7" +
    "\005\uffe7\006\uffe7\007\uffe7\010\uffe7\011\uffe7\012\uffe7\013" +
    "\uffe7\014\uffe7\015\uffe7\022\uffe7\024\uffe7\036\uffe7\042\uffe7" +
    "\043\uffe7\044\uffe7\045\uffe7\046\uffe7\047\uffe7\001\002\000" +
    "\024\022\012\024\035\036\017\042\020\043\006\044\030" +
    "\045\025\046\015\047\036\001\002\000\010\007\133\010" +
    "\134\015\135\001\002\000\040\004\007\005\037\006\016" +
    "\011\010\012\011\013\014\022\012\024\035\036\017\042" +
    "\020\043\006\044\030\045\025\046\015\047\036\001\002" +
    "\000\024\022\012\024\035\036\017\042\020\043\006\044" +
    "\030\045\025\046\015\047\036\001\002\000\052\002\uffe5" +
    "\004\uffe5\005\uffe5\006\uffe5\007\uffe5\010\uffe5\011\uffe5\012" +
    "\uffe5\013\uffe5\014\uffe5\015\uffe5\022\uffe5\024\uffe5\036\uffe5" +
    "\042\uffe5\043\uffe5\044\uffe5\045\uffe5\046\uffe5\047\uffe5\001" +
    "\002\000\004\017\137\001\002\000\040\004\007\005\037" +
    "\006\016\011\010\012\011\013\014\022\012\024\035\036" +
    "\017\042\020\043\006\044\030\045\025\046\015\047\036" +
    "\001\002\000\046\004\007\005\037\006\016\007\uffe2\010" +
    "\uffe2\011\010\012\011\013\014\015\uffe2\022\012\024\035" +
    "\036\017\042\020\043\006\044\030\045\025\046\015\047" +
    "\036\001\002\000\042\004\007\005\037\006\016\011\010" +
    "\012\011\013\014\015\142\022\012\024\035\036\017\042" +
    "\020\043\006\044\030\045\025\046\015\047\036\001\002" +
    "\000\052\002\uffe4\004\uffe4\005\uffe4\006\uffe4\007\uffe4\010" +
    "\uffe4\011\uffe4\012\uffe4\013\uffe4\014\uffe4\015\uffe4\022\uffe4" +
    "\024\uffe4\036\uffe4\042\uffe4\043\uffe4\044\uffe4\045\uffe4\046" +
    "\uffe4\047\uffe4\001\002\000\004\017\144\001\002\000\040" +
    "\004\007\005\037\006\016\011\010\012\011\013\014\022" +
    "\012\024\035\036\017\042\020\043\006\044\030\045\025" +
    "\046\015\047\036\001\002\000\046\004\007\005\037\006" +
    "\016\007\uffe3\010\uffe3\011\010\012\011\013\014\015\uffe3" +
    "\022\012\024\035\036\017\042\020\043\006\044\030\045" +
    "\025\046\015\047\036\001\002\000\042\004\007\005\037" +
    "\006\016\011\010\012\011\013\014\015\147\022\012\024" +
    "\035\036\017\042\020\043\006\044\030\045\025\046\015" +
    "\047\036\001\002\000\052\002\uffe6\004\uffe6\005\uffe6\006" +
    "\uffe6\007\uffe6\010\uffe6\011\uffe6\012\uffe6\013\uffe6\014\uffe6" +
    "\015\uffe6\022\uffe6\024\uffe6\036\uffe6\042\uffe6\043\uffe6\044" +
    "\uffe6\045\uffe6\046\uffe6\047\uffe6\001\002\000\004\036\151" +
    "\001\002\000\006\037\ufff5\042\152\001\002\000\006\037" +
    "\ufff3\041\ufff3\001\002\000\004\037\157\001\002\000\006" +
    "\037\ufff4\041\155\001\002\000\004\042\156\001\002\000" +
    "\006\037\ufff2\041\ufff2\001\002\000\042\004\007\005\037" +
    "\006\016\011\010\012\011\013\014\014\161\022\012\024" +
    "\035\036\017\042\020\043\006\044\030\045\025\046\015" +
    "\047\036\001\002\000\044\004\007\005\037\006\016\011" +
    "\010\012\011\013\014\014\165\015\166\022\012\024\035" +
    "\036\017\042\020\043\006\044\030\045\025\046\015\047" +
    "\036\001\002\000\024\022\012\024\035\036\017\042\020" +
    "\043\006\044\030\045\025\046\015\047\036\001\002\000" +
    "\044\004\ufff1\005\ufff1\006\ufff1\011\ufff1\012\ufff1\013\ufff1" +
    "\014\ufff1\015\ufff1\022\ufff1\024\ufff1\036\ufff1\042\ufff1\043" +
    "\ufff1\044\ufff1\045\ufff1\046\ufff1\047\ufff1\001\002\000\004" +
    "\040\164\001\002\000\044\004\uffee\005\uffee\006\uffee\011" +
    "\uffee\012\uffee\013\uffee\014\uffee\015\uffee\022\uffee\024\uffee" +
    "\036\uffee\042\uffee\043\uffee\044\uffee\045\uffee\046\uffee\047" +
    "\uffee\001\002\000\024\022\012\024\035\036\017\042\020" +
    "\043\006\044\030\045\025\046\015\047\036\001\002\000" +
    "\052\002\ufff6\004\ufff6\005\ufff6\006\ufff6\007\ufff6\010\ufff6" +
    "\011\ufff6\012\ufff6\013\ufff6\014\ufff6\015\ufff6\022\ufff6\024" +
    "\ufff6\036\ufff6\042\ufff6\043\ufff6\044\ufff6\045\ufff6\046\ufff6" +
    "\047\ufff6\001\002\000\044\004\ufff0\005\ufff0\006\ufff0\011" +
    "\ufff0\012\ufff0\013\ufff0\014\ufff0\015\ufff0\022\ufff0\024\ufff0" +
    "\036\ufff0\042\ufff0\043\ufff0\044\ufff0\045\ufff0\046\ufff0\047" +
    "\ufff0\001\002\000\004\040\171\001\002\000\044\004\uffef" +
    "\005\uffef\006\uffef\011\uffef\012\uffef\013\uffef\014\uffef\015" +
    "\uffef\022\uffef\024\uffef\036\uffef\042\uffef\043\uffef\044\uffef" +
    "\045\uffef\046\uffef\047\uffef\001\002\000\014\016\uffd4\017" +
    "\uffd4\037\uffd4\040\uffd4\041\uffd4\001\002\000\004\004\007" +
    "\001\002\000\024\022\012\024\035\036\017\042\020\043" +
    "\006\044\030\045\025\046\015\047\036\001\002\000\004" +
    "\040\176\001\002\000\024\022\012\024\035\036\017\042" +
    "\020\043\006\044\030\045\025\046\015\047\036\001\002" +
    "\000\004\037\200\001\002\000\004\016\201\001\002\000" +
    "\040\004\007\005\037\006\016\011\010\012\011\013\014" +
    "\022\012\024\035\036\017\042\020\043\006\044\030\045" +
    "\025\046\015\047\036\001\002\000\042\004\007\005\037" +
    "\006\016\011\010\012\011\013\014\015\203\022\012\024" +
    "\035\036\017\042\020\043\006\044\030\045\025\046\015" +
    "\047\036\001\002\000\052\002\uffe0\004\uffe0\005\uffe0\006" +
    "\uffe0\007\uffe0\010\uffe0\011\uffe0\012\uffe0\013\uffe0\014\uffe0" +
    "\015\uffe0\022\uffe0\024\uffe0\036\uffe0\042\uffe0\043\uffe0\044" +
    "\uffe0\045\uffe0\046\uffe0\047\uffe0\001\002\000\004\016\205" +
    "\001\002\000\040\004\007\005\037\006\016\011\010\012" +
    "\011\013\014\022\012\024\035\036\017\042\020\043\006" +
    "\044\030\045\025\046\015\047\036\001\002\000\042\004" +
    "\007\005\037\006\016\011\010\012\011\013\014\015\207" +
    "\022\012\024\035\036\017\042\020\043\006\044\030\045" +
    "\025\046\015\047\036\001\002\000\052\002\uffe1\004\uffe1" +
    "\005\uffe1\006\uffe1\007\uffe1\010\uffe1\011\uffe1\012\uffe1\013" +
    "\uffe1\014\uffe1\015\uffe1\022\uffe1\024\uffe1\036\uffe1\042\uffe1" +
    "\043\uffe1\044\uffe1\045\uffe1\046\uffe1\047\uffe1\001\002\000" +
    "\004\035\211\001\002\000\024\022\012\024\035\036\017" +
    "\042\020\043\006\044\030\045\025\046\015\047\036\001" +
    "\002\000\004\040\213\001\002\000\052\002\ufff7\004\ufff7" +
    "\005\ufff7\006\ufff7\007\ufff7\010\ufff7\011\ufff7\012\ufff7\013" +
    "\ufff7\014\ufff7\015\ufff7\022\ufff7\024\ufff7\036\ufff7\042\ufff7" +
    "\043\ufff7\044\ufff7\045\ufff7\046\ufff7\047\ufff7\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\211\000\044\002\020\003\042\004\022\005\040\006" +
    "\003\007\012\010\004\011\032\016\021\017\037\020\041" +
    "\025\026\026\033\027\025\030\030\031\023\032\031\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\022\011\047\024\203\025\046\026" +
    "\033\027\025\030\030\031\023\032\031\001\001\000\002" +
    "\001\001\000\014\011\047\027\171\030\030\031\023\032" +
    "\031\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\022\011\047\024\123\025\046\026\033\027" +
    "\025\030\030\031\023\032\031\001\001\000\022\011\047" +
    "\024\121\025\046\026\033\027\025\030\030\031\023\032" +
    "\031\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\006\011\047\032\054\001\001\000\002" +
    "\001\001\000\024\011\047\015\044\024\045\025\046\026" +
    "\033\027\025\030\030\031\023\032\031\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\040\004" +
    "\043\005\040\006\003\007\012\010\004\011\032\016\021" +
    "\017\037\020\041\025\026\026\033\027\025\030\030\031" +
    "\023\032\031\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\022\011\047\024\052\025\046\026\033\027\025\030\030" +
    "\031\023\032\031\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\026\011\047" +
    "\022\060\023\057\024\056\025\046\026\033\027\025\030" +
    "\030\031\023\032\031\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\022\011" +
    "\047\024\063\025\046\026\033\027\025\030\030\031\023" +
    "\032\031\001\001\000\002\001\001\000\002\001\001\000" +
    "\012\011\047\030\110\031\023\032\031\001\001\000\012" +
    "\011\047\030\107\031\023\032\031\001\001\000\012\011" +
    "\047\030\106\031\023\032\031\001\001\000\010\011\047" +
    "\031\105\032\031\001\001\000\012\011\047\030\104\031" +
    "\023\032\031\001\001\000\012\011\047\030\103\031\023" +
    "\032\031\001\001\000\010\011\047\031\076\032\031\001" +
    "\001\000\012\011\047\030\075\031\023\032\031\001\001" +
    "\000\002\001\001\000\002\001\001\000\006\011\047\032" +
    "\102\001\001\000\006\011\047\032\101\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\016\011\047\026" +
    "\115\027\025\030\030\031\023\032\031\001\001\000\016" +
    "\011\047\026\114\027\025\030\030\031\023\032\031\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\022\011\047\024\120\025\046\026\033\027\025\030" +
    "\030\031\023\032\031\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\042\003" +
    "\125\004\022\005\040\006\003\007\012\010\004\011\032" +
    "\016\021\017\037\020\041\025\026\026\033\027\025\030" +
    "\030\031\023\032\031\001\001\000\042\004\043\005\040" +
    "\006\003\007\012\010\004\011\032\016\021\017\037\020" +
    "\041\021\131\025\026\026\033\027\025\030\030\031\023" +
    "\032\031\001\001\000\042\003\145\004\022\005\040\006" +
    "\003\007\012\010\004\011\032\016\021\017\037\020\041" +
    "\025\026\026\033\027\025\030\030\031\023\032\031\001" +
    "\001\000\002\001\001\000\022\011\047\024\142\025\046" +
    "\026\033\027\025\030\030\031\023\032\031\001\001\000" +
    "\002\001\001\000\042\003\140\004\022\005\040\006\003" +
    "\007\012\010\004\011\032\016\021\017\037\020\041\025" +
    "\026\026\033\027\025\030\030\031\023\032\031\001\001" +
    "\000\022\011\047\024\135\025\046\026\033\027\025\030" +
    "\030\031\023\032\031\001\001\000\002\001\001\000\002" +
    "\001\001\000\042\003\137\004\022\005\040\006\003\007" +
    "\012\010\004\011\032\016\021\017\037\020\041\025\026" +
    "\026\033\027\025\030\030\031\023\032\031\001\001\000" +
    "\040\004\043\005\040\006\003\007\012\010\004\011\032" +
    "\016\021\017\037\020\041\025\026\026\033\027\025\030" +
    "\030\031\023\032\031\001\001\000\040\004\043\005\040" +
    "\006\003\007\012\010\004\011\032\016\021\017\037\020" +
    "\041\025\026\026\033\027\025\030\030\031\023\032\031" +
    "\001\001\000\002\001\001\000\002\001\001\000\042\003" +
    "\144\004\022\005\040\006\003\007\012\010\004\011\032" +
    "\016\021\017\037\020\041\025\026\026\033\027\025\030" +
    "\030\031\023\032\031\001\001\000\040\004\043\005\040" +
    "\006\003\007\012\010\004\011\032\016\021\017\037\020" +
    "\041\025\026\026\033\027\025\030\030\031\023\032\031" +
    "\001\001\000\040\004\043\005\040\006\003\007\012\010" +
    "\004\011\032\016\021\017\037\020\041\025\026\026\033" +
    "\027\025\030\030\031\023\032\031\001\001\000\002\001" +
    "\001\000\002\001\001\000\006\012\152\013\153\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\042\004\161\005\040" +
    "\006\003\007\012\010\004\011\032\014\157\016\021\017" +
    "\037\020\041\025\026\026\033\027\025\030\030\031\023" +
    "\032\031\001\001\000\040\004\166\005\040\006\003\007" +
    "\012\010\004\011\032\016\021\017\037\020\041\025\026" +
    "\026\033\027\025\030\030\031\023\032\031\001\001\000" +
    "\022\011\047\024\162\025\046\026\033\027\025\030\030" +
    "\031\023\032\031\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\022\011\047\024\167\025\046" +
    "\026\033\027\025\030\030\031\023\032\031\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\005\173\001\001\000" +
    "\022\011\047\024\174\025\046\026\033\027\025\030\030" +
    "\031\023\032\031\001\001\000\002\001\001\000\022\011" +
    "\047\024\176\025\046\026\033\027\025\030\030\031\023" +
    "\032\031\001\001\000\002\001\001\000\002\001\001\000" +
    "\042\003\201\004\022\005\040\006\003\007\012\010\004" +
    "\011\032\016\021\017\037\020\041\025\026\026\033\027" +
    "\025\030\030\031\023\032\031\001\001\000\040\004\043" +
    "\005\040\006\003\007\012\010\004\011\032\016\021\017" +
    "\037\020\041\025\026\026\033\027\025\030\030\031\023" +
    "\032\031\001\001\000\002\001\001\000\002\001\001\000" +
    "\042\003\205\004\022\005\040\006\003\007\012\010\004" +
    "\011\032\016\021\017\037\020\041\025\026\026\033\027" +
    "\025\030\030\031\023\032\031\001\001\000\040\004\043" +
    "\005\040\006\003\007\012\010\004\011\032\016\021\017" +
    "\037\020\041\025\026\026\033\027\025\030\030\031\023" +
    "\032\031\001\001\000\002\001\001\000\002\001\001\000" +
    "\022\011\047\024\211\025\046\026\033\027\025\030\030" +
    "\031\023\032\031\001\001\000\002\001\001\000\002\001" +
    "\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$Parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$Parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public Symbol do_action(
    int                        act_num,
    lr_parser parser,
    Stack            stack,
    int                        top)
    throws Exception
  {
    /* call code in generated class */
    return action_obj.CUP$Parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}



    // Para registrar errores sintácticos
    public void syntax_error(Symbol s) {
        System.err.println("Error sintáctico en línea " + (s.left + 1) + ", columna " + (s.right + 1) + ": " + s.value);
    }

    // Para errores fatales
    public void unrecovered_syntax_error(Symbol s) throws Exception {
        System.err.println("Error irrecuperable en línea " + (s.left + 1) + ", columna " + (s.right + 1));
    }


/** Cup generated class to encapsulate user supplied action code.*/
@SuppressWarnings({"rawtypes", "unchecked", "unused"})
class CUP$Parser$actions {
  private final Parser parser;

  /** Constructor */
  CUP$Parser$actions(Parser parser) {
    this.parser = parser;
  }

  /** Method 0 with the actual generated action code for actions 0 to 300. */
  public final Symbol CUP$Parser$do_action_part00000000(
    int                        CUP$Parser$act_num,
    lr_parser CUP$Parser$parser,
    Stack            CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws Exception
    {
      /* Symbol object for return from actions */
      Symbol CUP$Parser$result;

      /* select the action based on the action number */
      switch (CUP$Parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= programa EOF 
            {
              Object RESULT =null;
		int start_valleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int start_valright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Program start_val = (Program)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		RESULT = start_val;
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$Parser$parser.done_parsing();
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // programa ::= declaraciones 
            {
              Program RESULT =null;
		int declsleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int declsright = ((Symbol)CUP$Parser$stack.peek()).right;
		List<Statement> decls = (List<Statement>)((Symbol) CUP$Parser$stack.peek()).value;
		
                RESULT = new Program(decls);
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("programa",0, ((Symbol)CUP$Parser$stack.peek()), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // declaraciones ::= declaracion 
            {
              List<Statement> RESULT =null;
		int declleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int declright = ((Symbol)CUP$Parser$stack.peek()).right;
		Statement decl = (Statement)((Symbol) CUP$Parser$stack.peek()).value;
		
                    List<Statement> decls = new ArrayList<>();
                    decls.add(decl);
                    RESULT = decls;
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("declaraciones",1, ((Symbol)CUP$Parser$stack.peek()), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // declaraciones ::= declaraciones declaracion 
            {
              List<Statement> RESULT =null;
		int declsleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int declsright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		List<Statement> decls = (List<Statement>)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int declleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int declright = ((Symbol)CUP$Parser$stack.peek()).right;
		Statement decl = (Statement)((Symbol) CUP$Parser$stack.peek()).value;
		
                    decls.add(decl);
                    RESULT = decls;
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("declaraciones",1, ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // declaracion ::= declaracion_variable 
            {
              Statement RESULT =null;
		int varleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int varright = ((Symbol)CUP$Parser$stack.peek()).right;
		VarDeclaration var = (VarDeclaration)((Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = var; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("declaracion",2, ((Symbol)CUP$Parser$stack.peek()), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // declaracion ::= declaracion_funcion 
            {
              Statement RESULT =null;
		int funcleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int funcright = ((Symbol)CUP$Parser$stack.peek()).right;
		FunctionDeclaration func = (FunctionDeclaration)((Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = func; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("declaracion",2, ((Symbol)CUP$Parser$stack.peek()), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // declaracion ::= declaracion_impresion 
            {
              Statement RESULT =null;
		int printleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int printright = ((Symbol)CUP$Parser$stack.peek()).right;
		PrintStatement print = (PrintStatement)((Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = print; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("declaracion",2, ((Symbol)CUP$Parser$stack.peek()), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // declaracion ::= estructura_control 
            {
              Statement RESULT =null;
		int ctrlleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int ctrlright = ((Symbol)CUP$Parser$stack.peek()).right;
		Statement ctrl = (Statement)((Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = ctrl; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("declaracion",2, ((Symbol)CUP$Parser$stack.peek()), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // declaracion ::= llamada_funcion SEMICOLON 
            {
              Statement RESULT =null;
		int callleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int callright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		FunctionCall call = (FunctionCall)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 RESULT = new ExpressionStatement(call); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("declaracion",2, ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // declaracion ::= expresion_asignacion SEMICOLON 
            {
              Statement RESULT =null;
		int exprleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int exprright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Expression expr = (Expression)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 RESULT = new ExpressionStatement(expr); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("declaracion",2, ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // declaracion_variable ::= DEFINE ID ASSIGN expresion SEMICOLON 
            {
              VarDeclaration RESULT =null;
		int idleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int idright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		String id = (String)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int exprleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int exprright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Expression expr = (Expression)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                          RESULT = new VarDeclaration(id, expr);
                      
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("declaracion_variable",3, ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // declaracion_funcion ::= FUNCTION ID LPAREN parametros RPAREN cuerpo_funcion END 
            {
              FunctionDeclaration RESULT =null;
		int idleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int idright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		String id = (String)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		int paramsleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int paramsright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		List<String> params = (List<String>)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int bodyleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int bodyright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		List<Statement> body = (List<Statement>)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                          RESULT = new FunctionDeclaration(id, params, body);
                      
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("declaracion_funcion",4, ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // parametros ::= 
            {
              List<String> RESULT =null;
		
                RESULT = new ArrayList<>();
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("parametros",8, ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // parametros ::= lista_parametros 
            {
              List<String> RESULT =null;
		int paramsleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int paramsright = ((Symbol)CUP$Parser$stack.peek()).right;
		List<String> params = (List<String>)((Symbol) CUP$Parser$stack.peek()).value;
		
                RESULT = params;
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("parametros",8, ((Symbol)CUP$Parser$stack.peek()), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // lista_parametros ::= ID 
            {
              List<String> RESULT =null;
		int idleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int idright = ((Symbol)CUP$Parser$stack.peek()).right;
		String id = (String)((Symbol) CUP$Parser$stack.peek()).value;
		
                      List<String> params = new ArrayList<>();
                      params.add(id);
                      RESULT = params;
                  
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("lista_parametros",9, ((Symbol)CUP$Parser$stack.peek()), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // lista_parametros ::= lista_parametros COMMA ID 
            {
              List<String> RESULT =null;
		int paramsleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int paramsright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		List<String> params = (List<String>)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int idleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int idright = ((Symbol)CUP$Parser$stack.peek()).right;
		String id = (String)((Symbol) CUP$Parser$stack.peek()).value;
		
                      params.add(id);
                      RESULT = params;
                  
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("lista_parametros",9, ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // cuerpo_funcion ::= declaracion 
            {
              List<Statement> RESULT =null;
		int declleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int declright = ((Symbol)CUP$Parser$stack.peek()).right;
		Statement decl = (Statement)((Symbol) CUP$Parser$stack.peek()).value;
		
                    List<Statement> body = new ArrayList<>();
                    body.add(decl);
                    RESULT = body;
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("cuerpo_funcion",10, ((Symbol)CUP$Parser$stack.peek()), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // cuerpo_funcion ::= cuerpo_funcion declaracion 
            {
              List<Statement> RESULT =null;
		int bodyleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int bodyright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		List<Statement> body = (List<Statement>)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int declleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int declright = ((Symbol)CUP$Parser$stack.peek()).right;
		Statement decl = (Statement)((Symbol) CUP$Parser$stack.peek()).value;
		
                    body.add(decl);
                    RESULT = body;
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("cuerpo_funcion",10, ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // cuerpo_funcion ::= cuerpo_funcion RETURN expresion SEMICOLON 
            {
              List<Statement> RESULT =null;
		int bodyleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int bodyright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		List<Statement> body = (List<Statement>)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int exprleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int exprright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Expression expr = (Expression)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                    body.add(new ReturnStatement(expr));
                    RESULT = body;
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("cuerpo_funcion",10, ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // cuerpo_funcion ::= RETURN expresion SEMICOLON 
            {
              List<Statement> RESULT =null;
		int exprleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int exprright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Expression expr = (Expression)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                    List<Statement> body = new ArrayList<>();
                    body.add(new ReturnStatement(expr));
                    RESULT = body;
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("cuerpo_funcion",10, ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // declaracion_impresion ::= PRINT lista_impresion SEMICOLON 
            {
              PrintStatement RESULT =null;
		int listleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int listright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		List<Expression> list = (List<Expression>)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                           RESULT = new PrintStatement(list);
                       
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("declaracion_impresion",5, ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // lista_impresion ::= expresion 
            {
              List<Expression> RESULT =null;
		int exprleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int exprright = ((Symbol)CUP$Parser$stack.peek()).right;
		Expression expr = (Expression)((Symbol) CUP$Parser$stack.peek()).value;
		
                     List<Expression> exprs = new ArrayList<>();
                     exprs.add(expr);
                     RESULT = exprs;
                 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("lista_impresion",11, ((Symbol)CUP$Parser$stack.peek()), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // lista_impresion ::= lista_impresion COMMA expresion 
            {
              List<Expression> RESULT =null;
		int listleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int listright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		List<Expression> list = (List<Expression>)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int exprleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int exprright = ((Symbol)CUP$Parser$stack.peek()).right;
		Expression expr = (Expression)((Symbol) CUP$Parser$stack.peek()).value;
		
                     list.add(expr);
                     RESULT = list;
                 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("lista_impresion",11, ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // estructura_control ::= estructura_if 
            {
              Statement RESULT =null;
		int ifStmtleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int ifStmtright = ((Symbol)CUP$Parser$stack.peek()).right;
		IfStatement ifStmt = (IfStatement)((Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = ifStmt; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("estructura_control",6, ((Symbol)CUP$Parser$stack.peek()), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // estructura_control ::= estructura_while 
            {
              Statement RESULT =null;
		int whileStmtleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int whileStmtright = ((Symbol)CUP$Parser$stack.peek()).right;
		WhileStatement whileStmt = (WhileStatement)((Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = whileStmt; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("estructura_control",6, ((Symbol)CUP$Parser$stack.peek()), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // estructura_control ::= estructura_loop 
            {
              Statement RESULT =null;
		int loopStmtleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int loopStmtright = ((Symbol)CUP$Parser$stack.peek()).right;
		LoopStatement loopStmt = (LoopStatement)((Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = loopStmt; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("estructura_control",6, ((Symbol)CUP$Parser$stack.peek()), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // estructura_if ::= IF expresion THEN declaraciones END 
            {
              IfStatement RESULT =null;
		int condleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int condright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Expression cond = (Expression)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int thenBodyleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int thenBodyright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		List<Statement> thenBody = (List<Statement>)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                    RESULT = new IfStatement(cond, thenBody, new ArrayList<>(), new ArrayList<>());
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("estructura_if",12, ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // estructura_if ::= IF expresion THEN declaraciones ELSE declaraciones END 
            {
              IfStatement RESULT =null;
		int condleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int condright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		Expression cond = (Expression)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		int thenBodyleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int thenBodyright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		List<Statement> thenBody = (List<Statement>)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int elseBodyleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int elseBodyright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		List<Statement> elseBody = (List<Statement>)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                    RESULT = new IfStatement(cond, thenBody, new ArrayList<>(), elseBody);
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("estructura_if",12, ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // estructura_if ::= IF expresion THEN declaraciones clauses_elseif END 
            {
              IfStatement RESULT =null;
		int condleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int condright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		Expression cond = (Expression)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		int thenBodyleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int thenBodyright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		List<Statement> thenBody = (List<Statement>)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int elseifClausesleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int elseifClausesright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		List<ElseIfClause> elseifClauses = (List<ElseIfClause>)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                    RESULT = new IfStatement(cond, thenBody, elseifClauses, new ArrayList<>());
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("estructura_if",12, ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // estructura_if ::= IF expresion THEN declaraciones clauses_elseif ELSE declaraciones END 
            {
              IfStatement RESULT =null;
		int condleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).left;
		int condright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).right;
		Expression cond = (Expression)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-6)).value;
		int thenBodyleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int thenBodyright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		List<Statement> thenBody = (List<Statement>)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		int elseifClausesleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int elseifClausesright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		List<ElseIfClause> elseifClauses = (List<ElseIfClause>)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int elseBodyleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int elseBodyright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		List<Statement> elseBody = (List<Statement>)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                    RESULT = new IfStatement(cond, thenBody, elseifClauses, elseBody);
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("estructura_if",12, ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // clauses_elseif ::= ELSEIF expresion THEN declaraciones 
            {
              List<ElseIfClause> RESULT =null;
		int condleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int condright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Expression cond = (Expression)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int bodyleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int bodyright = ((Symbol)CUP$Parser$stack.peek()).right;
		List<Statement> body = (List<Statement>)((Symbol) CUP$Parser$stack.peek()).value;
		
                    List<ElseIfClause> clauses = new ArrayList<>();
                    clauses.add(new ElseIfClause(cond, body));
                    RESULT = clauses;
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("clauses_elseif",15, ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // clauses_elseif ::= clauses_elseif ELSEIF expresion THEN declaraciones 
            {
              List<ElseIfClause> RESULT =null;
		int clausesleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int clausesright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		List<ElseIfClause> clauses = (List<ElseIfClause>)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		int condleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int condright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Expression cond = (Expression)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int bodyleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int bodyright = ((Symbol)CUP$Parser$stack.peek()).right;
		List<Statement> body = (List<Statement>)((Symbol) CUP$Parser$stack.peek()).value;
		
                    clauses.add(new ElseIfClause(cond, body));
                    RESULT = clauses;
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("clauses_elseif",15, ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // estructura_while ::= WHILE expresion DO declaraciones END 
            {
              WhileStatement RESULT =null;
		int condleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int condright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Expression cond = (Expression)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int bodyleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int bodyright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		List<Statement> body = (List<Statement>)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                       RESULT = new WhileStatement(cond, body);
                   
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("estructura_while",13, ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // estructura_loop ::= LOOP LPAREN declaracion_variable expresion SEMICOLON expresion RPAREN DO declaraciones END 
            {
              LoopStatement RESULT =null;
		int initleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).left;
		int initright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).right;
		VarDeclaration init = (VarDeclaration)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-7)).value;
		int condleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).left;
		int condright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).right;
		Expression cond = (Expression)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-6)).value;
		int incrleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int incrright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		Expression incr = (Expression)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		int bodyleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int bodyright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		List<Statement> body = (List<Statement>)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                      RESULT = new LoopStatement(init, cond, incr, body);
                  
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("estructura_loop",14, ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-9)), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // llamada_funcion ::= ID LPAREN argumentos RPAREN 
            {
              FunctionCall RESULT =null;
		int idleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int idright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		String id = (String)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int argsleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int argsright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		List<Expression> args = (List<Expression>)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                      RESULT = new FunctionCall(id, args);
                  
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("llamada_funcion",7, ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // argumentos ::= 
            {
              List<Expression> RESULT =null;
		
                RESULT = new ArrayList<>();
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("argumentos",16, ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // argumentos ::= lista_argumentos 
            {
              List<Expression> RESULT =null;
		int argsleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int argsright = ((Symbol)CUP$Parser$stack.peek()).right;
		List<Expression> args = (List<Expression>)((Symbol) CUP$Parser$stack.peek()).value;
		
                RESULT = args;
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("argumentos",16, ((Symbol)CUP$Parser$stack.peek()), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // lista_argumentos ::= expresion 
            {
              List<Expression> RESULT =null;
		int exprleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int exprright = ((Symbol)CUP$Parser$stack.peek()).right;
		Expression expr = (Expression)((Symbol) CUP$Parser$stack.peek()).value;
		
                      List<Expression> args = new ArrayList<>();
                      args.add(expr);
                      RESULT = args;
                  
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("lista_argumentos",17, ((Symbol)CUP$Parser$stack.peek()), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // lista_argumentos ::= lista_argumentos COMMA expresion 
            {
              List<Expression> RESULT =null;
		int argsleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int argsright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		List<Expression> args = (List<Expression>)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int exprleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int exprright = ((Symbol)CUP$Parser$stack.peek()).right;
		Expression expr = (Expression)((Symbol) CUP$Parser$stack.peek()).value;
		
                      args.add(expr);
                      RESULT = args;
                  
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("lista_argumentos",17, ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // expresion ::= expresion_asignacion 
            {
              Expression RESULT =null;
		int exprleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int exprright = ((Symbol)CUP$Parser$stack.peek()).right;
		Expression expr = (Expression)((Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = expr; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("expresion",18, ((Symbol)CUP$Parser$stack.peek()), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // expresion_asignacion ::= ID ASSIGN expresion 
            {
              Expression RESULT =null;
		int idleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int idright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		String id = (String)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int exprleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int exprright = ((Symbol)CUP$Parser$stack.peek()).right;
		Expression expr = (Expression)((Symbol) CUP$Parser$stack.peek()).value;
		
                          RESULT = new AssignmentExpression(id, expr);
                      
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("expresion_asignacion",19, ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // expresion_asignacion ::= expresion_logica 
            {
              Expression RESULT =null;
		int exprleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int exprright = ((Symbol)CUP$Parser$stack.peek()).right;
		Expression expr = (Expression)((Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = expr; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("expresion_asignacion",19, ((Symbol)CUP$Parser$stack.peek()), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // expresion_logica ::= expresion_relacional 
            {
              Expression RESULT =null;
		int exprleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int exprright = ((Symbol)CUP$Parser$stack.peek()).right;
		Expression expr = (Expression)((Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = expr; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("expresion_logica",20, ((Symbol)CUP$Parser$stack.peek()), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // expresion_logica ::= expresion_relacional AND expresion_logica 
            {
              Expression RESULT =null;
		int leftleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int leftright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Expression left = (Expression)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int rightleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int rightright = ((Symbol)CUP$Parser$stack.peek()).right;
		Expression right = (Expression)((Symbol) CUP$Parser$stack.peek()).value;
		
                      RESULT = new BinaryExpression(left, "AND", right);
                  
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("expresion_logica",20, ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // expresion_logica ::= expresion_relacional OR expresion_logica 
            {
              Expression RESULT =null;
		int leftleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int leftright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Expression left = (Expression)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int rightleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int rightright = ((Symbol)CUP$Parser$stack.peek()).right;
		Expression right = (Expression)((Symbol) CUP$Parser$stack.peek()).value;
		
                      RESULT = new BinaryExpression(left, "OR", right);
                  
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("expresion_logica",20, ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // expresion_logica ::= NOT expresion_relacional 
            {
              Expression RESULT =null;
		int exprleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int exprright = ((Symbol)CUP$Parser$stack.peek()).right;
		Expression expr = (Expression)((Symbol) CUP$Parser$stack.peek()).value;
		
                      RESULT = new UnaryExpression("NOT", expr);
                  
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("expresion_logica",20, ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // expresion_relacional ::= expresion_aditiva 
            {
              Expression RESULT =null;
		int exprleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int exprright = ((Symbol)CUP$Parser$stack.peek()).right;
		Expression expr = (Expression)((Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = expr; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("expresion_relacional",21, ((Symbol)CUP$Parser$stack.peek()), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // expresion_relacional ::= expresion_aditiva LT expresion_aditiva 
            {
              Expression RESULT =null;
		int leftleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int leftright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Expression left = (Expression)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int rightleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int rightright = ((Symbol)CUP$Parser$stack.peek()).right;
		Expression right = (Expression)((Symbol) CUP$Parser$stack.peek()).value;
		
                          RESULT = new BinaryExpression(left, "<", right);
                      
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("expresion_relacional",21, ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // expresion_relacional ::= expresion_aditiva GT expresion_aditiva 
            {
              Expression RESULT =null;
		int leftleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int leftright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Expression left = (Expression)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int rightleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int rightright = ((Symbol)CUP$Parser$stack.peek()).right;
		Expression right = (Expression)((Symbol) CUP$Parser$stack.peek()).value;
		
                          RESULT = new BinaryExpression(left, ">", right);
                      
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("expresion_relacional",21, ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // expresion_relacional ::= expresion_aditiva LE expresion_aditiva 
            {
              Expression RESULT =null;
		int leftleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int leftright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Expression left = (Expression)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int rightleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int rightright = ((Symbol)CUP$Parser$stack.peek()).right;
		Expression right = (Expression)((Symbol) CUP$Parser$stack.peek()).value;
		
                          RESULT = new BinaryExpression(left, "<=", right);
                      
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("expresion_relacional",21, ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // expresion_relacional ::= expresion_aditiva GE expresion_aditiva 
            {
              Expression RESULT =null;
		int leftleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int leftright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Expression left = (Expression)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int rightleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int rightright = ((Symbol)CUP$Parser$stack.peek()).right;
		Expression right = (Expression)((Symbol) CUP$Parser$stack.peek()).value;
		
                          RESULT = new BinaryExpression(left, ">=", right);
                      
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("expresion_relacional",21, ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // expresion_relacional ::= expresion_aditiva EQ expresion_aditiva 
            {
              Expression RESULT =null;
		int leftleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int leftright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Expression left = (Expression)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int rightleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int rightright = ((Symbol)CUP$Parser$stack.peek()).right;
		Expression right = (Expression)((Symbol) CUP$Parser$stack.peek()).value;
		
                          RESULT = new BinaryExpression(left, "==", right);
                      
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("expresion_relacional",21, ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // expresion_relacional ::= expresion_aditiva NE expresion_aditiva 
            {
              Expression RESULT =null;
		int leftleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int leftright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Expression left = (Expression)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int rightleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int rightright = ((Symbol)CUP$Parser$stack.peek()).right;
		Expression right = (Expression)((Symbol) CUP$Parser$stack.peek()).value;
		
                          RESULT = new BinaryExpression(left, "!=", right);
                      
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("expresion_relacional",21, ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // expresion_aditiva ::= expresion_aditiva PLUS expresion_multiplicativa 
            {
              Expression RESULT =null;
		int leftleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int leftright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Expression left = (Expression)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int rightleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int rightright = ((Symbol)CUP$Parser$stack.peek()).right;
		Expression right = (Expression)((Symbol) CUP$Parser$stack.peek()).value;
		
                       RESULT = new BinaryExpression(left, "+", right);
                   
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("expresion_aditiva",22, ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // expresion_aditiva ::= expresion_aditiva MINUS expresion_multiplicativa 
            {
              Expression RESULT =null;
		int leftleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int leftright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Expression left = (Expression)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int rightleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int rightright = ((Symbol)CUP$Parser$stack.peek()).right;
		Expression right = (Expression)((Symbol) CUP$Parser$stack.peek()).value;
		
                       RESULT = new BinaryExpression(left, "-", right);
                   
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("expresion_aditiva",22, ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // expresion_aditiva ::= expresion_multiplicativa 
            {
              Expression RESULT =null;
		int exprleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int exprright = ((Symbol)CUP$Parser$stack.peek()).right;
		Expression expr = (Expression)((Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = expr; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("expresion_aditiva",22, ((Symbol)CUP$Parser$stack.peek()), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // expresion_multiplicativa ::= expresion_multiplicativa TIMES factor 
            {
              Expression RESULT =null;
		int leftleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int leftright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Expression left = (Expression)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int rightleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int rightright = ((Symbol)CUP$Parser$stack.peek()).right;
		Expression right = (Expression)((Symbol) CUP$Parser$stack.peek()).value;
		
                             RESULT = new BinaryExpression(left, "*", right);
                         
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("expresion_multiplicativa",23, ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // expresion_multiplicativa ::= expresion_multiplicativa DIVIDE factor 
            {
              Expression RESULT =null;
		int leftleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int leftright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Expression left = (Expression)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int rightleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int rightright = ((Symbol)CUP$Parser$stack.peek()).right;
		Expression right = (Expression)((Symbol) CUP$Parser$stack.peek()).value;
		
                             RESULT = new BinaryExpression(left, "/", right);
                         
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("expresion_multiplicativa",23, ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // expresion_multiplicativa ::= factor 
            {
              Expression RESULT =null;
		int fleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int fright = ((Symbol)CUP$Parser$stack.peek()).right;
		Expression f = (Expression)((Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = f; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("expresion_multiplicativa",23, ((Symbol)CUP$Parser$stack.peek()), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // factor ::= LPAREN expresion RPAREN 
            {
              Expression RESULT =null;
		int exprleft = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int exprright = ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Expression expr = (Expression)((Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 RESULT = expr; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("factor",24, ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // factor ::= llamada_funcion 
            {
              Expression RESULT =null;
		int callleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int callright = ((Symbol)CUP$Parser$stack.peek()).right;
		FunctionCall call = (FunctionCall)((Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = call; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("factor",24, ((Symbol)CUP$Parser$stack.peek()), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // factor ::= ID 
            {
              Expression RESULT =null;
		int idleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int idright = ((Symbol)CUP$Parser$stack.peek()).right;
		String id = (String)((Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = new VariableExpression(id); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("factor",24, ((Symbol)CUP$Parser$stack.peek()), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // factor ::= INT 
            {
              Expression RESULT =null;
		int valleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int valright = ((Symbol)CUP$Parser$stack.peek()).right;
		Integer val = (Integer)((Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = new LiteralExpression(val); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("factor",24, ((Symbol)CUP$Parser$stack.peek()), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // factor ::= FLOAT 
            {
              Expression RESULT =null;
		int valleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int valright = ((Symbol)CUP$Parser$stack.peek()).right;
		Float val = (Float)((Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = new LiteralExpression(val); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("factor",24, ((Symbol)CUP$Parser$stack.peek()), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // factor ::= STRING 
            {
              Expression RESULT =null;
		int valleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int valright = ((Symbol)CUP$Parser$stack.peek()).right;
		String val = (String)((Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = new LiteralExpression(val); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("factor",24, ((Symbol)CUP$Parser$stack.peek()), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // factor ::= TRUE 
            {
              Expression RESULT =null;
		int valleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int valright = ((Symbol)CUP$Parser$stack.peek()).right;
		Boolean val = (Boolean)((Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = new LiteralExpression(val); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("factor",24, ((Symbol)CUP$Parser$stack.peek()), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // factor ::= FALSE 
            {
              Expression RESULT =null;
		int valleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int valright = ((Symbol)CUP$Parser$stack.peek()).right;
		Boolean val = (Boolean)((Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = new LiteralExpression(val); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("factor",24, ((Symbol)CUP$Parser$stack.peek()), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // factor ::= MINUS factor 
            {
              Expression RESULT =null;
		int factorleft = ((Symbol)CUP$Parser$stack.peek()).left;
		int factorright = ((Symbol)CUP$Parser$stack.peek()).right;
		Expression factor = (Expression)((Symbol) CUP$Parser$stack.peek()).value;
		
            RESULT = new UnaryExpression("-", factor);
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("factor",24, ((Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number "+CUP$Parser$act_num+"found in internal parse table");

        }
    } /* end of method */

  /** Method splitting the generated action code into several parts. */
  public final Symbol CUP$Parser$do_action(
    int                        CUP$Parser$act_num,
    lr_parser CUP$Parser$parser,
    Stack            CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws Exception
    {
              return CUP$Parser$do_action_part00000000(
                               CUP$Parser$act_num,
                               CUP$Parser$parser,
                               CUP$Parser$stack,
                               CUP$Parser$top);
    }
}

}
